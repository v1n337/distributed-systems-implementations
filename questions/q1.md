### RPC aims to make remote procedure calls look like local calls. When does that illusion fail (i.e., in what case remote calls are different from local calls)? How does the paper address this case? If you are writing a program using RPCs, how would you handle this case? Hint: "precisely once" and "at most once" semantics.

The illusion of making invoking remote procedures fails in the event of machine and communication failures of the callee. Despite the caller environment still being fully operational, it would seem from the point of view of an end-user that the system is failing, because at least one process on the caller system will be suspended indefinitely until a response is received, or receive an exception. If a callee fails before it was able to execute the procedure or if it fails while acknowledging the procedure completion of the procedure, the caller receives the same feedback: that the callee is unreachable or has failed for some reason.

The implementation described in the paper guarantees that the procedure is executed 'precisely once', if the call is returned to the user. The RPC mechanism in the paper holds the caller machine accountable to keep retrying requests that were presumed to have failed. This presumption is based on the fact that the caller hasn't yet received a result packet containing the call identifier it used when the request was originally sent. The 'precisely once' execution of the described RPC mechanism is achieved by the callee system keeping track of historical requests. This allows the callee to discard the requests whose call identifier has already been logged as completed and the result sent back to the caller. Such occurrences might take place due to re-transmissions by the caller. An exception to this scenario is if the procedure being invoked is idempotent, for which the callee machine would not need to keep track of whether a procedure was executed as part of a previous request already.

If I was writing a program using RPCs, the logic to handle to the execution count semantics would need to be present at the callee system i.e. the exported of the RPC interface. I would use a hashmap/data-dictionary to maintain a mapping of the activities (machine ID + process ID) to the current sequence number associated with it. For each procedure call, the callee code would first look up the dictionary - ​[​O(1) time complexity​]​ - to check if the sequence number is lesser than the current sequence number associated with the machine ID + process ID for that specific caller. If the sequence number received is lesser than or equal to the sequence number in the dictionary, the request can be discarded as duplicate. Else, the procedure call is processed after updating the dictionary to contain the latest sequence number.

The semantics of RPC re-transmissions would depend on the type of application it's being used for. For instance 'precisely once' would make a lot of sense to have in a financial transaction environment, where the application layer requires strong guarantees that an RPC is executed only once. 
On the other hand, an 'at most once' sem​​antic might make sense to have for a scenario like tweet likes, where missing out on a single unit of the metric doesn't cause a huge impact. For this the caller application could merely choose to invoke the RPC, but never wait for an acknowledgement before processing.
